{
    "collab_server" : "",
    "contents" : "## Colocalisation analysis, implementing method of Giambartolomei et al. 2014\n##\n## changed API to pass in vectors instead of dataframe\ncoloc.fast <- function(beta1, se1, beta2, se2, \n                       priorsd1 = 1, priorsd2 = 1, priorc1 = 1e-4, priorc2 = 1e-4, priorc12 = 1e-5, \n                       rounded = 6) {\n  abf1 <- abf.Wakefield(beta1, se1, priorsd1, log = TRUE)\n  abf2 <- abf.Wakefield(beta2, se2, priorsd2, log = TRUE)\n  w <- which(!is.na(abf1) & !is.na(abf2))\n  ## Fill in zeros not filter out, thanks Karl and Karsten!!!!\n  nv <- length(w)\n  abf1 <- norm1(c(0, abf1[w]), log = TRUE)\n  abf2 <- norm1(c(0, abf2[w]), log = TRUE)\n  res <- data.frame(hypothesis = paste0(\"H\", 0:4),\n                    label = c(\"No association\",\n                      \"One variant associated with phenotype 1 only\",\n                      \"One variant associated with phenotype 2 only\",\n                      \"Two variants separately associated with phenotypes 1 and 2\",\n                      \"One variant associated with phenotypes 1 and 2\"),\n                    prior = norm1(c(1, priorc1*nv, priorc2*nv, priorc1*priorc2*nv*(nv - 1), priorc12*nv)),\n                    bf = if (nv > 0) c(abf1[1]*abf2[1], \n                      sum(abf1[-1])*abf2[1]/nv, \n                      abf1[1]*sum(abf2[-1])/nv, \n                      (sum(abf1[-1])*sum(abf2[-1]) - sum(abf1[-1]*abf2[-1]))/(nv*(nv - 1)), \n                      sum(abf1[-1]*abf2[-1])/nv) else rep(NA, 5))\n  res$bf <- res$bf/max(res$bf) # was: res$bf/res$bf[1] # caused division by zero for strongly colocalized signals\n  res$posterior <- norm1(res$prior*res$bf)\n  ## compute model averaged effect size ratios\n  mw <- abf1[-1]*abf2[-1] # model weights\n  alpha12 <- sum(beta1[w]/beta2[w]*mw)/sum(mw)\n  alpha21 <- sum(beta2[w]/beta1[w]*mw)/sum(mw)\n  if (is.finite(rounded)) {\n    res$posterior = round(res$posterior, rounded)\n  }\n  return(list(results = res, nvariants = length(w), alpha12 = alpha12, alpha21 = alpha21))\n}\n\n## TO DO\n## Function rename rationalization\n##   regionplot.region -> gtxregion\n## Sanitation for required length 1\n## Wrapper for SQL queries that must return data frame of 1 or >=1 rows\n\n\n\ncoloc <- function(analysis1, analysis2,\n                  chrom, pos_start, pos_end, pos, \n                  hgncid, ensemblid, rs, surround = 500000,\n                  entity, entity1, entity2,\n                  style = 'Z', \n                  dbc = getOption(\"gtx.dbConnection\", NULL)) {\n  gtxdbcheck(dbc)\n\n  ## Determine genomic region from arguments\n  xregion <- gtxregion(chrom = chrom, pos_start = pos_start, pos_end = pos_end, pos = pos, \n                       hgncid = hgncid, ensemblid = ensemblid, rs = rs, surround = surround,\n                       dbc = dbc)\n  chrom = xregion$chrom\n  pos_start = xregion$pos_start\n  pos_end = xregion$pos_end\n\n  ## substitute generic entity for entity1 and entity2 if needed\n  if (missing(entity1) && !missing(entity)) entity1 <- entity\n  if (missing(entity2) && !missing(entity)) entity2 <- entity\n\n  ## Determine entity, if required, for each analysis\n  xentity1 <- gtxentity(analysis1, entity = entity1, hgncid = hgncid, ensemblid = ensemblid)\n  xentity2 <- gtxentity(analysis2, entity = entity2, hgncid = hgncid, ensemblid = ensemblid)\n\n  ## Get association statistics\n  res <- sqlWrapper(dbc, \n                    sprintf('SELECT \n                                 t1.beta AS beta1, t1.se AS se1, \n                                 t2.beta AS beta2, t2.se AS se2 \n                             FROM \n                                 (SELECT\n                                      chrom, pos, ref, alt, beta, se, pval \n                                  FROM %s.gwas_results \n                                  WHERE\n                                      %s AND %s %s\n                                 ) AS t1 \n                                 FULL JOIN \n                                 (SELECT \n                                      chrom, pos, ref, alt, beta, se, pval \n                                  FROM %s.gwas_results \n                                  WHERE \n                                      %s AND %s %s\n                                 ) AS t2\n                                 USING (chrom, pos, ref, alt);',\n                            gtxanalysisdb(analysis1), \n                            gtxwhat(analysis1 = analysis1), # analysis1= argument allows only one analysis\n                            gtxwhere(chrom, pos_ge = pos_start, pos_le = pos_end),\n                            if (!is.null(xentity1)) sprintf(' AND feature=\\'%s\\'', xentity1$entity) else '', # FIXME will change to entity\n                            gtxanalysisdb(analysis2), \n                            gtxwhat(analysis1 = analysis2), # analysis1= argument allows only one analysis\n                            gtxwhere(chrom, pos_ge = pos_start, pos_le = pos_end),\n                            if (!is.null(xentity2)) sprintf(' AND feature=\\'%s\\'', xentity2$entity) else ''  # FIXME will change to entity\n                            ),\n                    uniq = FALSE) # expect >=1 rows\n\n  gtxlog('coloc query returned ', nrow(res), ' rows')\n\n  resc <- coloc.fast(res$beta1, res$se1, res$beta2, res$se2)\n\n  pdesc1 <- sqlWrapper(dbc,\n                       sprintf('SELECT description FROM analyses WHERE analysis = \\'%s\\';',\n                               sanitize(analysis1, type = 'alphanum')))$description\n  if (!is.null(xentity1)) pdesc1 <- paste(xentity1$entity_label, pdesc1)\n  pdesc2 <- sqlWrapper(dbc,\n                       sprintf('SELECT description FROM analyses WHERE analysis = \\'%s\\';',\n                               sanitize(analysis2, type = 'alphanum')))$description\n  if (!is.null(xentity2)) pdesc2 <- paste(xentity2$entity_label, pdesc2)\n \n  if (identical(style, 'Z')) {\n      ## would like to draw one sided plot, but unclear what to do when sign(beta1)==0. HMMMM FIXME\n      with(res, {\n          plot(beta1/se1,\n               beta2/se2,\n               pch = 21, bg = rgb(.67, .67, .67, .5), col = rgb(.33, .33, .33, .5), cex = 1,\n               ann = FALSE)\n\t  abline(h = 0)\n\t  abline(v = 0)\n          mtext.fit(main = paste0('H', c('0', 'x', 'y', 'x,y', 'xy'), '=', round(resc$results$posterior*100), '%', collapse = ', '),\n                    xlab = paste(pdesc1, 'association Z score'),\n                    ylab = paste(pdesc2, 'association Z score'))\n\t  mtext(paste0('colocalization at chr', chrom, ':', pos_start, '-', pos_end), 3, 3)\n      })\n  } else if (identical(style, 'beta')) {\n      ## would like to draw one sided plot, but unclear what to do when sign(beta1)==0. HMMMM FIXME\n      with(res, {\n          plot(beta1,\n               beta2,\n               pch = 21, bg = rgb(.67, .67, .67, .5), col = rgb(.33, .33, .33, .5), cex = 1,\n               ann = FALSE)\n\t  abline(h = 0)\n\t  abline(v = 0)\n          mtext.fit(main = paste0('H', c('0', 'x', 'y', 'x,y', 'xy'), '=', round(resc$results$posterior*100), '%', collapse = ', '),\n                    xlab = paste(pdesc1, 'association effect size'),\n                    ylab = paste(pdesc2, 'association effect size'))\n\t  mtext(paste0('colocalization at chr', chrom, ':', pos_start, '-', pos_end), 3, 3)\n      })\n  } else if (identical(style, 'none')) {\n      # do not draw plot\n  } else {\n      stop('Unrecognized style; must be Z, beta, or none')\n  }\n\n  return(resc)\n}\n\n## analysis1 must have entities, analysis2 must not\n## note that surround=0 is a sensible default because\n## of the region expansion performed within this function\nmulticoloc.data <- function(analysis1, analysis2,\n                            chrom, pos_start, pos_end, pos, \n                            hgncid, ensemblid, rs, surround = 0,\n##                            entity, entity1, entity2,\n##                            style = 'Z', \n                            hard_clip = FALSE, \n                            dbc = getOption(\"gtx.dbConnection\", NULL)) {\n  gtxdbcheck(dbc)\n  ## note there is a *niche* case where analysis2 would have an entity\n  ## e.g. coloc ABC123 expression against expression of all other nearby entities\n\n  \n  ## Determine genomic region from arguments\n  xregion <- gtxregion(chrom = chrom, pos_start = pos_start, pos_end = pos_end, pos = pos, \n                       hgncid = hgncid, ensemblid = ensemblid, rs = rs, surround = surround,\n                       dbc = dbc)\n  chrom = xregion$chrom\n  pos_start = xregion$pos_start\n  pos_end = xregion$pos_end\n\n  ## Currently only works if analysis1 all in the same db table\n  db1 <- sanitize1(unique(sapply(analysis1, gtxanalysisdb)), type = 'alphanum')\n  \n#  ## substitute generic entity for entity1 and entity2 if needed\n#  if (missing(entity1) && !missing(entity)) entity1 <- entity\n#  if (missing(entity2) && !missing(entity)) entity2 <- entity\n\n#  ## Determine entity, if required, for each analysis\n#  xentity1 <- gtxentity(analysis1, entity = entity1, hgncid = hgncid, ensemblid = ensemblid)\n#  xentity2 <- gtxentity(analysis2, entity = entity2, hgncid = hgncid, ensemblid = ensemblid)\n\n  ## We want to include complete association statistics for all entities that\n  ## partly or fully overlap the query region.  (This cannot be done\n  ## by adding a buffer region since entities are of variable size, and have\n  ## association statistics that extend by unknown intervals around the\n  ## entity [GTEx 1Mb cis-regions are not guaranteed].)\n  ##\n  ## Therefore we run a series of queries, to\n  ## 1. Find all entities with >=1 association statistic within the overlap query region\n  ## 2. Find the interval that includes all association statistics for those entities\n  ## 3. Do a coloc query for this region (with WHERE ... AND entity=)\n  ##\n  ## Note that for efficiency regions we want query 3. to be by a defined physical region\n  ## rather than directly selecting on WHERE entity IN ...\n  \n  gtxlog('Query region is chr', chrom, ':', pos_start, '-', pos_end, \n         ' (', prettyNum(pos_end - pos_start, big.mark = ',', scientific = FALSE), ' bp)')\n\n  eq <- sqlWrapper(dbc, \n                    sprintf('SELECT \n                                 DISTINCT feature\n                             FROM %s.gwas_results\n                             WHERE\n                                 %s AND %s ;',\n                            db1, \n                            gtxwhat(analysis = analysis1), \n                            gtxwhere(chrom = chrom, pos_ge = pos_start, pos_le = pos_end)),\n                    uniq = FALSE)$feature\n  ## FIXME this may return zero rows, should handle gracefully\n  gtxlog('Query region includes association statistics for ', length(eq), ' entities')\n\n  if (!hard_clip) {\n      ep <- sqlWrapper(dbc, \n                       sprintf('SELECT \n                                 min(pos) as minpos, max(pos) as maxpos\n                             FROM %s.gwas_results\n                             WHERE\n                                 %s AND %s ;',\n                             db1, \n                             gtxwhat(analysis = analysis1),\n                             gtxwhere(chrom = chrom, entity = eq)))\n      pos_start <- ep$minpos\n      pos_end <- ep$maxpos\n      gtxlog('Expanded region is chr', chrom, ':', pos_start, '-', pos_end,\n             ' (', prettyNum(pos_end - pos_start, big.mark = ',', scientific = FALSE), ' bp)')\n  }\n\n  ## We use a (INNER) JOIN and silently drop rows that don't match\n  ## FIXME if hard_clip can make this query run faster by not selecting on entity\n  t0 <- as.double(Sys.time())\n  res <- sqlWrapper(dbc,\n                    sprintf('SELECT \n                                 t1.analysis AS analysis1, t1.entity AS entity1,\n                                 t1.beta AS beta1, t1.se AS se1, \n                                 t2.beta AS beta2, t2.se AS se2 \n                             FROM \n                                 (SELECT\n                                      chrom, pos, ref, alt, analysis, feature AS entity, beta, se\n                                  FROM %s.gwas_results \n                                  WHERE\n                                      %s AND %s AND %s\n                                 ) AS t1 \n                             JOIN \n                                 (SELECT \n                                      chrom, pos, ref, alt, beta, se\n                                  FROM %s.gwas_results \n                                  WHERE \n                                      %s AND %s \n                                 ) AS t2\n                             USING (chrom, pos, ref, alt);',\n                            db1, \n                            gtxwhat(analysis = analysis1),\n                            gtxwhere(chrom = chrom, pos_ge = pos_start, pos_le = pos_end),\n                            gtxwhere(chrom = chrom, entity = eq), \n                            gtxanalysisdb(analysis2),\n                            gtxwhat(analysis1 = analysis2), # analysis1= argument allows only one analysis\n                            gtxwhere(chrom = chrom, pos_ge = pos_start, pos_le = pos_end)\n                            ),\n                    uniq = FALSE) # expect >=1 rows\n  t1 <- as.double(Sys.time())\n  gtxlog('Results query returned ', nrow(res), ' rows in ', round(t1 - t0, 3), 's.')\n  return(res)\n}\n\nmulticoloc <- function(analysis1, analysis2,\n                       chrom, pos_start, pos_end, pos, \n                       hgncid, ensemblid, rs, surround = 0,\n                       hard_clip = FALSE, style = 'heatplot',\n                       thresh_analysis = 0.1, thresh_entity = 0.1, \n                       dbc = getOption(\"gtx.dbConnection\", NULL)) {\n  gtxdbcheck(dbc)\n\n  ## get summary stats\n  ss <- multicoloc.data(analysis1 = analysis1, analysis2 = analysis2,\n                         chrom = chrom, pos_start = pos_start, pos_end = pos_end, pos = pos, \n                         hgncid = hgncid, ensemblid = ensemblid, rs = rs,\n                         surround = surround, hard_clip = hard_clip, \n                         dbc = dbc)\n  ss <- data.table(ss) # could inline\n  \n  res <- sqlWrapper(dbc, \n                    sprintf('SELECT * FROM genes WHERE %s ORDER BY pos_start;',\n                            gtxwhere(ensemblid = unique(ss$entity))), # FIXME not guaranteed entity_type is ENSG\n                    uniq = FALSE)\n  res$entity <- res$ensemblid # FIXME not guaranteed entity_type\n  analyses <- unique(ss$analysis1)\n\n  t0 <- as.double(Sys.time())\n  resc1 <- ss[ ,\n              subset(coloc.fast(beta1, se1, beta2, se2)$results, hypothesis == 'H4')$posterior,\n              by = .(analysis1, entity1)]\n  names(resc1)[3] <- 'Hxy'\n  resc <- reshape(resc1, direction = 'wide', idvar = 'entity1', timevar = 'analysis1')\n  res <- cbind(res, resc[match(res$entity, resc$entity1), ])\n  #for (this_analysis in analyses) {\n  #    resc <- do.call(rbind,\n  #                    lapply(unique(res$entity), function(this_entity) {\n  #                        return(subset(coloc.fast(subset(ss, analysis1 == this_analysis & entity1 == this_entity))$results,\n  #                                      hypothesis == 'H4')$posterior)\n  #                    }))\n  #    colnames(resc) <- paste0('Hxy', '_', this_analysis)\n  #    res <- cbind(res, resc)\n  #}\n  t1 <- as.double(Sys.time())\n  gtxlog('Colocalization analyzed for ', sum(!is.na(res[ , paste0('Hxy', '.', analyses)])), ' pairs in ', round(t1 - t0, 3), 's')\n\n  if (identical(style, 'none')) {\n      ## do nothing\n  } else if (identical(style, 'heatplot')) {\n      zmat <- as.matrix(res[ , paste0('Hxy', '.', analyses)])\n      colnames(zmat) <- analyses\n      rownames(zmat) <- with(res, ifelse(hgncid != '', as.character(hgncid), as.character(ensemblid))) # FIXME will this work for all entity types\n      ## thresh_analysis <- thresh_analysis*max(zmat, na.rm = TRUE) # threshold could be relative instead of absolute\n      ## thresh_entity <- thresh_entity*max(zmat, na.rm = TRUE) # threshold, ditto\n      ## FIXME, if nothing passes thresholds, should adapt gracefully\n      zmat <- zmat[apply(zmat, 1, function(x) return(any(x >= thresh_entity, na.rm = TRUE) && any(!is.na(x)))) ,\n                   order(apply(zmat, 2, function(x) if (any(x >= thresh_analysis, na.rm = TRUE)) max(x, na.rm = TRUE) else NA), na.last = NA),\n                   drop = FALSE]\n      multicoloc.plot(zmat, dbc = dbc)\n  } else {\n      stop('unknown style [ ', style, ' ]')\n  }\n  \n  return(res)\n}\n\n## Input, a matrix of z values with analysis as column names and entity as row names \nmulticoloc.plot <- function(zmat,\n                            dbc = getOption(\"gtx.dbConnection\", NULL)) {\n    gtxdbcheck(dbc)\n    \n    ## Query plot labels for analyses\n    label_y <- sqlWrapper(dbc, \n                         sprintf('SELECT analysis, label FROM analyses WHERE %s',\n                                 gtxwhat(analysis = colnames(zmat))),\n                         uniq = FALSE)\n    label_y <- label_y$label[match(colnames(zmat), label_y$analysis)]\n    ## label_y <- ifelse(!is.na(label_y), label_y, colnames(zmat)) # fall back to analysis if label lookup failed\n    \n    plot.new()\n    x_labelmax <- .4 # max fraction of total x space to use for analysis descriptions\n    y_linesep <- 2. # spacing desired as multiple of strheight()\n    \n    cex_ylab <- 1.\n    while (TRUE) {\n        y_used <- sum(strheight(label_y, cex = cex_ylab)*y_linesep)\n        x_used <- max(strwidth(label_y, cex = cex_ylab))\n        if (y_used <= 1. && x_used <= x_labelmax) break\n        cex_ylab <- cex_ylab*min(1./y_used, x_labelmax/x_used)\n    }\n    x_labeluse <- x_used\n    \n    cex_values <- 1.\n    while (TRUE) {\n        y_used <- strheight('000', cex = cex_values)*ncol(zmat)*y_linesep\n        x_used <- strwidth('000', cex = cex_values)*nrow(zmat)\n        if (y_used <= 1. && x_used <= (1. - x_labeluse)) break\n        cex_values <- cex_values*min(1./y_used, (1. - x_labeluse)/x_used)\n    }\n\n    plot.window(c(-x_labeluse/(1. - x_labeluse), 1.)*(nrow(zmat) + .5), c(.5, ncol(zmat) + .5))\n    abline(v = 0)\n    \n    image(x = 1:nrow(zmat), y = 1:ncol(zmat),\n          z = zmat,\n          zlim = c(0, 1),\n          col = rgb(1, 100:0/100, 100:0/100,),\n          add = TRUE) # should add options for different colour scalings\n\n    text(0, 1:ncol(zmat), label_y, pos = 2, cex = cex_ylab)\n    for (idx in 1:ncol(zmat)) {\n        zvals <- as.integer(round(zmat[, idx]*100))\n        text(1:nrow(zmat), idx, ifelse(!is.na(zvals), sprintf('%02i', zvals), ''), cex = cex_values)\n    }\n    axis(1, at = 1:nrow(zmat),\n         labels = rownames(zmat),\n         las = 2, cex.axis = .5, font = 3)\n    box()\n\n    return(invisible(NULL))\n}\n\nmulticoloc.kbs <- function(analysis1, analysis2,\n                       chrom, pos_start, pos_end, pos, \n                       hgncid, ensemblid, rs, surround = 0,\n                       hard_clip = FALSE, style = 'heatplot',\n                       thresh_analysis = 0.1, thresh_entity = 0.1, \n                       dbc = getOption(\"gtx.dbConnection\", NULL)) {\n  gtxdbcheck(dbc)\n\n  ## get summary stats\n  ss <- multicoloc.data(analysis1 = analysis1, analysis2 = analysis2,\n                         chrom = chrom, pos_start = pos_start, pos_end = pos_end, pos = pos, \n                         hgncid = hgncid, ensemblid = ensemblid, rs = rs,\n                         surround = surround, hard_clip = hard_clip, \n                         dbc = dbc) %>% \n          as.data.table()\n  \n  res <- sqlWrapper(dbc, \n                    sprintf('SELECT * FROM genes WHERE %s ORDER BY pos_start;',\n                            gtxwhere(ensemblid = unique(ss$entity))), # FIXME not guaranteed entity_type is ENSG\n                    uniq = FALSE)\n  res$entity <- res$ensemblid # FIXME not guaranteed entity_type\n\n  ret <- ss[ ,\n              coloc.fast(beta1, se1, beta2, se2)$results,\n              by = .(analysis1, entity1)] %>% \n         dplyr::select(-label, -prior, -bf) %>% \n         left_join(., \n                  res %>% \n                    rename(entity1 = entity) %>% \n                    select(entity1, hgncid), \n                  by = \"entity1\") %>% \n        dplyr::select(-posterior, -hypothesis, everything()) %>%\n        rename(tissue = analysis1) %>%\n        rename(ensembl_id = entity1) %>%\n        rename(hgnc_id = hgncid)\n  \n  return(ret)\n}",
    "created" : 1518635774621.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1065348255",
    "id" : "2BC7FBB9",
    "lastKnownWriteTime" : 1518635610,
    "last_content_update" : 1518635610,
    "path" : "~/R/gtx/R/coloc.R",
    "project_path" : "R/coloc.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}